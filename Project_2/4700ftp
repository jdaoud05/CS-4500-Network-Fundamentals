#!/usr/bin/env python3

import socket
import re
import sys


# Parse the input. Extract the parameters
# Example input: ftp://john:secret123@ftp.example.com/path
def parse_ftp():
    if len(sys.argv) < 2:
        sys.stderr.write("Usage: ./4700ftp [operation] [param1] [param2]")
        sys.exit(1)

    ftp_url = sys.argv[-1]
    match = re.search(r'ftp://([^:]+):([^@]+)@([^/]+)', ftp_url)
    if not match:
        sys.stderr.write("Error: Incorrect FTP URL Format")
        sys.exit(1)
    
    # Return the user, password, and hostname
    return str(match.group(1)), str(match.group(2)), str(match.group(3))

# Connect to the FTP server
def control_connect(HOST, PORT):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    return sock

def recv_reply(sock):
    
   buffer = ""
   while b"\r\n" not in buffer:
       data = sock.recv(4096)
       if not data:
           break
       buffer += data  
   return buffer.decode(errors="ignore")

def multi_line(sock):
    complete = False

    response = b""

    # Receive the data until there's a string like %d%d%d xxxx
    # This indicates its the end of the line
    while True:
        data = sock.recv(4096)
        if not data:
            break
        response += data

        lines = response.split(b'\r\n')
        for line in lines:
            match = re.match(rb'^(\d{3})', line)


            if match:
                code = match.group(0)
                if code + b'-' in line:
                    pass
                if code + b' ' in line:
                    complete = True
                    break
            else: 
                break
        if complete:
            break

    return response.decode('utf-8', errors='ignore')



# Helper function used to send commands
def send_command(sock, command):
    sock.send(command.encode() + b"\r\n")
    return multi_line(sock)
 

 
def login(sock, username, password):
    response = send_command(sock, f"USER {username}")
    print(f"Server: USER {username}")
    if password:
        response = send_command(sock, f"PASS {password}")
        print(f"Server: PASS {password}")
    return response

# Send PASV command. Open a separate port for data transfer
# This is used for actual file/directory data transfer
def pasv_connect(control_sock):
    reply = send_command(control_sock, "PASV")
    print(reply)

    match = re.search(r'\(([^)]+)\)', reply)
    if match:
        inside = match.group(1).split(',')
        ip = '.'.join(inside[0:4])

        port = (int(inside[4])*256) + int(inside[5])

        data_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        data_sock.connect((ip, port))
        return data_sock   
    else:
        raise Exception("PASV failed: " + reply)

# Send "Type I" 8-bit binary
def set_up(control_sock):
    type_msg = send_command(control_sock, "TYPE I")
    print(type_msg)
    
    mode_msg = send_command(control_sock, "MODE S")
    print(mode_msg)

    stru_msg = send_command(control_sock, "STRU F")
    print(stru_msg)

    return type_msg, mode_msg, stru_msg
def quit(control_sock):
    quit_msg = send_command(control_sock, "QUIT")
    print(quit_msg)

    return quit_msg


def extract_path():
    re_path = re.search("^ftp://[^/]+/(.*)$", sys.argv[-1])
    path = str(re_path.group(1))
    return path




# Sends LIST, to list all files in the FTP server
def list(control_sock, data_sock):
    reply = send_command(control_sock, "LIST")
    print(reply)
    
    buffer = b""
    while True:
        data = data_sock.recv(4096)
        if not data:
            break
        buffer += data
    data_sock.close()

    print(buffer.decode())



def delete(control_sock, path):
    path = extract_path()

    reply = send_command(control_sock, f"DELE {path}")
    

    control_sock.close()
    return reply

def create_dir(control_sock, path):

    path = extract_path()

    reply = send_command(control_sock, f"MKD {path}")

    
    control_sock.close()

    return reply

def remove_dir(control_sock, path):

    path = extract_path()
    print(path)

    reply = send_command(control_sock, f"RMD {path}")
    print(reply)

    return reply


# def remove_file(control_sock, data_sock):
def upload(control_sock, data_sock, local_path):
    with open(local_path, 'rb') as f:
        file_data = f.read()
    

    reply = send_command(control_sock, f"STOR {local_path}")
    #control_sock.close()
    print(reply)

    data_sock.sendall(file_data)
    print(file_data)
    data_sock.close()

    reply = multi_line(control_sock)
    print(reply)



def download(control_sock, data_sock, path):

    # issue. it's not reading the data and writing it
    # it's onl ycreating a new file
    path = extract_path()
    reply = send_command(control_sock, f"RETR {path}")


    # ISSUE: data from file is not being read
    # how do we read aata from a file already in an ftp server
    with open(path, 'wb') as d:
        while True:
            data = data_sock.recv(4096)
            print(f"THIS DATA: {data}")
            if not data:
                break
            d.write(data)

    data_sock.close()
        
    print(f"DATA: {data}")
       

    #control_sock.close()

    reply = multi_line(control_sock)
    print(reply)




def input(control_sock, data_sock):

    re_path = re.search("^ftp://[^/]+(/.*)$", sys.argv[-1])
    path = str(re_path.group(1))
    print(path)

 

    if len(sys.argv) < 3:
        sys.stderr.write("Usage: ./4700ftp [operation] [param1] [param2]")
        sys.exit(1)



    if sys.argv[1] == 'ls':
        list(control_sock, data_sock)
    if sys.argv[1] == 'rm':
         delete(control_sock, data_sock, f"{path}")
    if sys.argv[1] == 'rmdir':
         remove_dir(control_sock, f"{path}")
    if sys.argv[1] == 'mkdir':
         create_dir(control_sock, f"{path}")
    if sys.argv[1] == 'cp':
         local_path = sys.argv[2] 
         print(local_path)
         upload(control_sock, data_sock, f"{local_path}")
    if sys.argv[1] == 'mv':
         download(control_sock, data_sock, f"{path}")

# user sends ls to term. client sends set up to server ... then client sends LIST to server...
#  then client sends QUIT to server


# ftp://USER:PASS@url

# USER = everything after ftp:// to :
# PASS = everything after : to @
# url = everything after @

def main():


    user, password, hostname = parse_ftp()
    #print(hostname)

    
#    serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock = control_connect(hostname, 21)
    multi_line(sock)
    login(sock, user, password)
    set_up(sock)

    data_sock = pasv_connect(sock)

    input(sock, data_sock)
    #quit(sock)
    #input(sock, data_sock)
    #delete(sock, data_sock)
    #remove_dir(sock)
    


if __name__ == "__main__":
    main()

# NEXT STEPS:
    # Implement support for making and deleting remote directories
        # ./4700ftp mkdir ftp://daoud.ja:password@ftp.4700.network/home/james/testdir
            # client sends: MKD <path-to-directory>\r\n
        # ./4700ftp rmdir ftp://ftp.4700.network/home/james/testdir
            # client sends: RMD <path-to-directory>\r\n